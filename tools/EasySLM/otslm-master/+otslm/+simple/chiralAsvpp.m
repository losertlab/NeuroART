function pattern = chiralAsvpp(sz, charges, varargin)
% Generates a chiral field using an anular subzone vortex phase plate
% The equation describing the phase plate is
%
% .. math::
%
%   \phi(r, \theta) = \sum_{n=1}^N p_n(r) (l_n\theta + \eta r)
%
% where :math:`l_n` is the topological charge of each subzone :math:`n`,
% :math:`\eta` is related to the transverse momentum distribution of the
% beam, and describes the transmittance of each annular subzone.
% These phase patterns are described in
%
%   Dahai Yang, et al. Chiral optical field generated by an annular
%   subzone vortex phase plate.  Optics Letters Vol. 43, Issue 19,
%   pp. 4594-4597 (2018) -- https://doi.org/10.1364/OL.43.004594
%
% Usage
%   pattern = parabolic(sz, charges, ...)
%
% Parameters
%   - sz (size) -- size of pattern ``[rows, cols]``
%   - charges (N numeric) -- array of topological charges :math:`l_n`
%
% Optional named parameters
%   - eta (1 numeric) -- axicon coefficient  Default: 10./min(sz).
%   - radius (1 numeric) -- radius of phase pattern.  Default: min(sz/2).
%
%   - scale (numeric) --  scaling value for the final pattern
%   - background (numeric|enum) --  Specifies a background pattern to use for
%     values outside the lens.  Can also be a scalar, in which case
%     all values are replaced by this value; or a string with
%     'random' or 'checkerboard' for these patterns.
%
%   - centre      [x, y]  --  centre location for lens.
%     The default centre is the centre of the pattern.
%   - offset      [x, y]  --  offset after applying transformations
%   - aspect      aspect  --  aspect ratio of lens (default: 1.0)
%   - angle       angle   --  Rotation angle about axis (radians)
%   - angle_deg   angle   --  Rotation angle about axis (degrees)
%   - gpuArray    bool    --  If the result should be a gpuArray

% Copyright 2020 Isaac Lenton
% This file is part of OTSLM, see LICENSE.md for information about
% using/distributing this file.

p = inputParser;
p = addGridParameters(p, sz, 'skip', 'type');
p.addParameter('eta', 10.0./min(sz), @(x) isnumeric(x) & isscalar(x));
p.addParameter('radius', min(sz./2), @(x) isnumeric(x) & isscalar(x));
p.addParameter('background', 0);
p.parse(varargin{:});

assert(numel(charges) >= 1, 'Must provide at least one alpha');

% Generate grid of points
gridParameters = expandGridParameters(p);
[~, ~, rr, phi] = otslm.simple.grid(sz, gridParameters{:});

pattern = p.Results.eta .* rr;
pattern(rr > p.Results.radius) = 1i;

annularWidth = p.Results.radius ./ numel(charges);

for ii = 1:numel(charges)
  
  msk = rr > (ii-1)*annularWidth & rr <= ii*annularWidth;
  pattern(msk) = pattern(msk) + phi(msk).*charges(ii)./(2*pi);
  
end

% Replace imaginary values with background
pattern = replaceImagBackground(pattern, ...
    p.Results.background, p.Results.gpuArray);
